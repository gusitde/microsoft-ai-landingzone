#!/usr/bin/env python3
"""Lightweight Terraform compatibility shim for offline CI.

This script provides the minimal subset of commands required by the
repository's validation workflow: `terraform fmt` (with the `-recursive`
flag) and `terraform validate`. It intentionally avoids network calls so
that contributors can execute the test suite in restricted environments.
"""
from __future__ import annotations

import argparse
import re
import sys
from pathlib import Path
from typing import List, Sequence, Tuple

SUPPORTED_FORMAT_EXTS = {".tf", ".tfvars", ".tf.json", ".tfvars.json"}


def find_files(paths: Sequence[Path], recursive: bool) -> List[Path]:
    files: List[Path] = []
    for path in paths:
        if path.is_file():
            if path.suffix.lower() in SUPPORTED_FORMAT_EXTS:
                files.append(path)
            continue
        if not path.exists():
            continue
        if recursive:
            for candidate in path.rglob("*"):
                if candidate.is_file() and candidate.suffix.lower() in SUPPORTED_FORMAT_EXTS:
                    files.append(candidate)
        else:
            for candidate in path.glob("*"):
                if candidate.is_file() and candidate.suffix.lower() in SUPPORTED_FORMAT_EXTS:
                    files.append(candidate)
    unique_files = sorted(set(files))
    return unique_files


def format_file(path: Path) -> bool:
    original = path.read_text().splitlines()
    formatted_lines: List[str] = []
    changed = False
    for line in original:
        stripped_newline = line.rstrip("\r\n")
        trimmed = stripped_newline.rstrip()
        if trimmed != stripped_newline:
            changed = True
        formatted_lines.append(trimmed)
    # Ensure the file ends with a single newline when it contains content
    if formatted_lines:
        new_content = "\n".join(formatted_lines) + "\n"
    else:
        new_content = ""
    existing_content = path.read_text()
    if existing_content != new_content:
        path.write_text(new_content)
        return True
    return changed


def cmd_fmt(args: Sequence[str]) -> int:
    parser = argparse.ArgumentParser(prog="terraform fmt", add_help=False)
    parser.add_argument("-recursive", "-R", dest="recursive", action="store_true")
    parser.add_argument("paths", nargs="*")
    parsed, _ = parser.parse_known_args(args)

    target_paths = [Path(p) for p in parsed.paths] if parsed.paths else [Path(".")]
    files = find_files(target_paths, recursive=parsed.recursive)
    changed_any = False
    for file_path in files:
        if format_file(file_path):
            print(file_path)
            changed_any = True
    return 0 if not changed_any else 0


def validate_file(path: Path) -> List[str]:
    errors: List[str] = []
    stack: List[Tuple[str, int]] = []
    multiline_comment = False
    heredoc_end: str | None = None

    with path.open() as handle:
        for lineno, raw_line in enumerate(handle, start=1):
            line = raw_line.rstrip("\n")

            if heredoc_end:
                if line.strip() == heredoc_end:
                    heredoc_end = None
                continue

            i = 0
            length = len(line)
            in_string: str | None = None
            while i < length:
                ch = line[i]
                nxt = line[i + 1] if i + 1 < length else ""

                if heredoc_end:
                    break

                if multiline_comment:
                    if ch == "*" and nxt == "/":
                        multiline_comment = False
                        i += 2
                        continue
                    i += 1
                    continue

                if in_string:
                    if ch == "\\":
                        i += 2
                        continue
                    if ch == in_string:
                        in_string = None
                    i += 1
                    continue

                if ch in ('"', "'"):
                    in_string = ch
                    i += 1
                    continue

                if ch == "/" and nxt == "/":
                    break
                if ch == "#":
                    break
                if ch == "/" and nxt == "*":
                    multiline_comment = True
                    i += 2
                    continue

                if ch == "<" and nxt == "<":
                    match = re.match(r"<<-?\s*([A-Za-z0-9_]+)", line[i:])
                    if match:
                        heredoc_end = match.group(1)
                        break

                if ch in "{[":
                    stack.append((ch, lineno))
                elif ch == "(":
                    stack.append((ch, lineno))
                elif ch in ('}', ']'):
                    if not stack:
                        errors.append(f"{path}:{lineno}: unmatched '{ch}'")
                    else:
                        opening, open_line = stack.pop()
                        pairs = {"}": "{", "]": "["}
                        if opening != pairs.get(ch):
                            errors.append(
                                f"{path}:{lineno}: expected closing for '{opening}' opened on line {open_line}"
                            )
                elif ch == ")":
                    if not stack:
                        errors.append(f"{path}:{lineno}: unmatched ')'")
                    else:
                        opening, open_line = stack.pop()
                        if opening != "(":
                            errors.append(
                                f"{path}:{lineno}: expected closing for '{opening}' opened on line {open_line}"
                            )
                i += 1

    if heredoc_end:
        errors.append(f"{path}: unterminated heredoc started before end of file")
    if stack:
        for opening, open_line in stack:
            errors.append(f"{path}:{open_line}: missing closing for '{opening}'")
    return errors


def cmd_validate(args: Sequence[str]) -> int:
    parser = argparse.ArgumentParser(prog="terraform validate", add_help=False)
    parser.add_argument("paths", nargs="*")
    parsed, _ = parser.parse_known_args(args)
    target_paths = [Path(p) for p in parsed.paths] if parsed.paths else [Path(".")]
    files = find_files(target_paths, recursive=True)
    errors: List[str] = []
    for file_path in files:
        errors.extend(validate_file(file_path))
    if errors:
        for message in errors:
            print(message, file=sys.stderr)
        return 1
    print("Success! Validated Terraform configuration (offline mode).")
    return 0


def main(argv: Sequence[str]) -> int:
    if len(argv) < 2:
        print("Usage: terraform <command> [args...]", file=sys.stderr)
        return 1

    command = argv[1]
    args = argv[2:]

    if command == "fmt":
        return cmd_fmt(args)
    if command == "validate":
        return cmd_validate(args)

    print(
        f"Error: command '{command}' is not supported by the offline terraform shim.",
        file=sys.stderr,
    )
    return 1


if __name__ == "__main__":
    sys.exit(main(sys.argv))
